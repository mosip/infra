name: Deploy External services of mosip using Helmsman

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Choose Helmsman mode: dry-run or apply"
        required: true
        default: "dry-run"
        type: choice
        options:
          - dry-run
          - apply   
  push:
    paths:
      - Helmsman/dsf/prereq-dsf.yaml
      - Helmsman/dsf/external-dsf.yaml

jobs:
  set-matrix:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - name: Checkout repository with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Get full commit history

      - name: Generate workflow matrix
        id: set-matrix
        run: |
          matrix_json='{"include":[]}'
          if [[ "$GITHUB_EVENT_NAME" == "workflow_dispatch" ]]; then
            matrix_json='{"include":[{"dsf_files":"prereq-dsf.yaml","wg_conf":"wg0"},{"dsf_files":"external-dsf.yaml","wg_conf":"wg1"}]}'
          else
            # Handle different event types properly
            if [[ "$GITHUB_EVENT_NAME" == "push" ]]; then
              # For push events, use GitHub's provided SHAs
              base_sha="${{ github.event.before}}"
              head_sha="${{ github.sha }}"
            elif [[ "$GITHUB_EVENT_NAME" == "pull_request" ]]; then
              # For PRs, compare against target branch
              base_sha="${{ github.event.pull_request.base.sha }}"
              head_sha="${{ github.event.pull_request.head.sha }}"
            fi

            # Get changed files safely
            changed_files=$(git diff --name-only "$base_sha" "$head_sha" -- 'Helmsman/dsf/' || echo "")
            
            entries=()
            
            # Check for exact file paths
            if echo "$changed_files" | grep -qx 'Helmsman/dsf/prereq-dsf.yaml'; then
              entries+=('{"dsf_files":"prereq-dsf.yaml","wg_conf":"wg0"}')
            fi
      
            if echo "$changed_files" | grep -qx 'Helmsman/dsf/external-dsf.yaml'; then
              entries+=('{"dsf_files":"external-dsf.yaml","wg_conf":"wg1"}')
            fi
            
            if [ ${#entries[@]} -gt 0 ]; then
              matrix_json="{\"include\":[$(IFS=,; echo "${entries[*]}")]}"
            fi
          fi

          echo "matrix=$matrix_json" >> $GITHUB_OUTPUT
  deploy:
    runs-on: ubuntu-latest
    needs: set-matrix
    strategy:
      matrix: ${{ fromJson(needs.set-matrix.outputs.matrix) }}
    environment: 
      name: ${{ github.ref_name }}  # Dynamic environment based on branch name
    env:
      KUBECONFIG: ${{ github.workspace }}/.kube/config
      PATH: ${{ github.workspace }}/istio-1.22.0/bin:${{ github.workspace }}/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
      ISTIOCTL_PATH: ${{ github.workspace }}/istio-1.22.0/bin/istioctl
      KUBECTL_PATH: ${{ github.workspace }}/.local/bin/kubectl
    steps:
      - name: Show matrix values
        run: |
          echo "Processing ${{ matrix.dsf_files }}"
          echo "Using WireGuard config: ${{ matrix.wg_conf }}"
          pwd

      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Setup kubectl, istioctl and kubeconfig
        run: |
          # Create directories
          mkdir -p ${{ github.workspace }}/.local/bin
          mkdir -p ${{ github.workspace }}/.kube
          
          # Install kubectl
          curl -LO https://dl.k8s.io/release/v1.31.3/bin/linux/amd64/kubectl
          chmod +x kubectl
          mv ./kubectl ${{ github.workspace }}/.local/bin/kubectl
          
          # Install istioctl
          curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.22.0 TARGET_ARCH=x86_64 sh -
          
          # Setup kubeconfig (hardcoded temporarily due to lack of admin access for secrets)
          cat > ${{ github.workspace }}/.kube/config << 'EOF'
          apiVersion: v1
          clusters:
          - cluster:
              certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUJlVENDQVIrZ0F3SUJBZ0lCQURBS0JnZ3Foa2pPUFFRREFqQWtNU0l3SUFZRFZRUUREQmx5YTJVeUxYTmwKY25abGNpMWpZVUF4TnpVME5UQTJNVFEzTUI0WERUSTFNRGd3TmpFNE5Ea3dOMW9YRFRNMU1EZ3dOREU0TkRrdwpOMW93SkRFaU1DQUdBMVVFQXd3WmNtdGxNaTF6WlhKMlpYSXRZMkZBTVRjMU5EVXdOakUwTnpCWk1CTUdCeXFHClNNNDlBZ0VHQ0NxR1NNNDlBd0VIQTBJQUJDVUZNVlovNGJ4M1hIcjQ1RnFvWFZjMk5qM2xzQ3prNTFOZlFEMWoKeWlaQnc1U2R3eGJ0YStuM1Q0WllwbmF6UDRac3hFSThmVkdrUEtrZUFUcXU1RlNqUWpCQU1BNEdBMVVkRHdFQgovd1FFQXdJQ3BEQVBCZ05WSFJNQkFmOEVCVEFEQVFIL01CMEdBMVVkRGdRV0JCUWRDSmhKNlZ5UlhiRFVrMFNHCnlvQWNCMGpjUHpBS0JnZ3Foa2pPUFFRREFnTklBREJGQWlFQTZnOHROUmFEUjFBcXVUYW80RytxNGFVTW9KcDQKQmZTc21Ed25wOVluRDhvQ0lBSEhuRUh1RmpTcTJkTGlBM1Z0eXhIWTJOWnc5VlA1RFVPZ0l0SmJ2eVB3Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K
              server: https://10.0.3.132:6443
              insecure-skip-tls-verify: true
            name: soil
          contexts:
          - context:
              cluster: soil
              user: soil
            name: soil
          current-context: soil
          kind: Config
          preferences: {}
          users:
          - name: soil
            user:
              client-certificate-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUJrakNDQVRpZ0F3SUJBZ0lJWWlLbHFzRWxTMG93Q2dZSUtvWkl6ajBFQXdJd0pERWlNQ0FHQTFVRUF3d1oKY210bE1pMWpiR2xsYm5RdFkyRkFNVGMxTkRVd05qRTBOekFlRncweU5UQTRNRFl4T0RRNU1EZGFGdzB5TmpBNApNRFl4T0RRNU1EZGFNREF4RnpBVkJnTlZCQW9URG5ONWMzUmxiVHB0WVhOMFpYSnpNUlV3RXdZRFZRUURFd3h6CmVYTjBaVzA2WVdSdGFXNHdXVEFUQmdjcWhrak9QUUlCQmdncWhrak9QUU1CQndOQ0FBUlZ2VmRNY1NzWGFSQ3IKNEdkcHVyNElRYXIvYTJXQUxZdjJUMGJiKzJwcURhdnM2b2NxM2t6c2lITXBSL3hNNXNieXBDSE9JWGpqZmlwcAppZVVQV29VNW8wZ3dSakFPQmdOVkhROEJBZjhFQkFNQ0JhQXdFd1lEVlIwbEJBd3dDZ1lJS3dZQkJRVUhBd0l3Ckh3WURWUjBqQkJnd0ZvQVVuZ2VFRW9pZDVGeWhKaitya1RvdWZwV1Vjd0l3Q2dZSUtvWkl6ajBFQXdJRFNBQXcKUlFJZ0tVaVJFcm5GYmUrSk52eHExWTI4Z3FKTURNWkFmYS81MTFpSG9PUGFrbXNDSVFEVzdKRmdvWnFBaVVUbQo4TU4zOFowVDZIU0QvQWNCc3NJenVEQ0dpSHhscnc9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQpNSUlCZURDQ0FSK2dBd0lCQWdJQkFEQUtCZ2dxaGtqT1BRUURBakFrTVNJd0lBWURWUVFEREJseWEyVXlMV05zCmFXVnVkQzFqWVVBeE56VTBOVEEyTVRRM01CNFhEVEkxTURnd05qRTRORGt3TjFvWERUTTFNRGd3TkRFNE5Ea3cKTjFvd0pERWlNQ0FHQTFVRUF3d1pjbXRsTWkxamJHbGxiblF0WTJGQU1UYzFORFV3TmpFME56QlpNQk1HQnlxRwpTTTQ5QWdFR0NDcUdTTTQ5QXdFSEEwSUFCRmQ5L3dyMlBlQ3htYnRORFdpSlZESjBGU0dYZWl1d2JpeW15SS9aCndwUVZSVlFFdEpHRElvZHYvM2VNcDZEbTUxUzVqQUhFb3hzL2tOM01OallwbjVTalFqQkFNQTRHQTFVZER3RUIKL3dRRUF3SUNwREFQQmdOVkhSTUJBZjhFQlRBREFRSC9NQjBHQTFVZERnUVdCQlNlQjRRU2lKM2tYS0VtUDZ1UgpPaTUrbFpSekFqQUtCZ2dxaGtqT1BRUERBZ05IQURCRUFpQUJCbE00N21oU0hRSGtzR1docWU0SEhKN0NscGhKClZ2M2RVTk1ndlZGWVRRSWdiVk1vVURBSnBVazYwaTVHWDNKM3JvMElLTy8wS1BNTjF3NmRTRXZTc3hVPQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==
              client-key-data: LS0tLS1CRUdJTiBFQyBQUklWQVRFIEtFWS0tLS0tCk1IY0NBUUVFSUp0d3BHOURBTEhDSFdUYWdLdVR4RGltdXlBUzZtSjdqR1I3TWtlSGNsUm1vQW9HQ0NxR1NNNDkKQXdFSG9VUURRZ0FFVmIxWFRIRXJGMmtRcStCbmFicStDRUdxLzJ0bGdDMkw5azlHMi90cWFnMnI3T3FIS3Q1TQo3SWh6S1VmOFRPYkc4cVFoemlGNDQzNHFhWW5sRDFxRk9RPT0KLS0tLS1FTkQgRUMgUFJJVkFURSBLRVktLS0tLQo=
          EOF
          chmod 400 ${{ github.workspace }}/.kube/config
          
          # Add tools to GitHub PATH for subsequent steps
          echo "${{ github.workspace }}/.local/bin" >> $GITHUB_PATH
          echo "${{ github.workspace }}/istio-1.22.0/bin" >> $GITHUB_PATH
          
          # Export environment variables for immediate use
          echo "KUBECTL_PATH=${{ github.workspace }}/.local/bin/kubectl" >> $GITHUB_ENV
          echo "ISTIOCTL_PATH=${{ github.workspace }}/istio-1.22.0/bin/istioctl" >> $GITHUB_ENV
          
          # Verify installations
          ${{ github.workspace }}/.local/bin/kubectl version --client
          ${{ github.workspace }}/istio-1.22.0/bin/istioctl version --remote=false
          ${{ github.workspace }}/.local/bin/kubectl config view

      - name: Set Default Mode
        run: |
          if [ -z "${{ github.event.inputs.mode }}" ]; then
            echo "HELMSMAN_MODE=apply" >> $GITHUB_ENV
          else
            echo "HELMSMAN_MODE=${{ github.event.inputs.mode }}" >> $GITHUB_ENV
          fi        

      - name: Setup ufw firewall
        run: |
          sudo ufw enable
          sudo ufw allow ssh
          sudo ufw allow 51820/udp
          sudo ufw status  

      - name: Install WireGuard
        run: sudo apt-get install -y wireguard

      - name: Configure WireGuard
        run: |
          echo "${{ secrets.CLUSTER_WIREGUARD_WG0 }}" | sudo tee /etc/wireguard/wg0.conf
          echo "${{ secrets.CLUSTER_WIREGUARD_WG1 }}" | sudo tee /etc/wireguard/wg1.conf

      - name: Start WireGuard
        run: |
          sudo chmod 600 /etc/wireguard/${{ matrix.wg_conf }}.conf
          sudo chmod 700 /etc/wireguard/
          sudo chmod 644 /lib/systemd/system/wg-quick@.service
          sudo systemctl daemon-reload
          sudo wg-quick up ${{ matrix.wg_conf }}
          sudo wg show ${{ matrix.wg_conf }}

      - name: Setup Helm
        run: |
          curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3
          sudo chmod 700 get_helm.sh
          sudo ./get_helm.sh
          helm version --client

      - name: Install Helmsman
        run: |
          curl -L https://github.com/Praqma/helmsman/releases/download/v3.17.1/helmsman_3.17.1_linux_amd64.tar.gz -o helmsman.tar.gz
          tar xzf helmsman.tar.gz
          sudo mv helmsman /usr/local/bin
          
          # Verify all tools are available
          echo "All tools verification:"
          echo "kubectl: $(which kubectl)"
          echo "istioctl: $(which istioctl)" 
          echo "helmsman: $(which helmsman)"
          
          kubectl version --client
          istioctl version --remote=false
          helmsman -v
      
      - name: Verify cluster access
        run: |
          # Verify tools are accessible
          echo "Verifying tool availability:"
          echo "kubectl path: $(which kubectl)"
          echo "istioctl path: $(which istioctl)"
          echo "KUBECONFIG: $KUBECONFIG"
          
          # Test kubectl functionality
          kubectl version --client
          kubectl get nodes
          kubectl cluster-info
          
          # Test istioctl functionality  
          istioctl version --remote=false
      - name: Check if external-dsf label is completed only for push
        if: github.event_name == 'push'
        run: |
          STATUS=$(kubectl get namespace default -o jsonpath='{.metadata.labels.external-dsf}')
          if [[ "$STATUS" != "completed" ]]; then
            echo "‚ùå External DSF not completed."
            exit 1
          fi
          
      - name: Initiate helmsman to apply the DSF configurations.
        run: |          
          export HOME="${{ github.workspace }}"
          export WORKDIR="$HOME/Helmsman"
          
          # Verify tools are available
          echo "Using kubectl: $(which kubectl)"
          echo "Using istioctl: $(which istioctl)"
          echo "Using kubeconfig: $KUBECONFIG"
          
          # Run helmsman with the determined mode
          helmsman --debug --${HELMSMAN_MODE} -f $WORKDIR/dsf/${{ matrix.dsf_files }}
      - name: Health Check External Pods
        run: |
          set -e
          NAMESPACES=( cattle-logging-system istio-system istio-operator httpbin keycloak kafka minio softhsm clamav activemq landing-page)
          for NS in "${NAMESPACES[@]}"; do
            echo "Checking health for namespace: $NS"
            for i in {1..30}; do
              UNREADY=$(kubectl get pods -n "$NS" --no-headers | grep -vE 'Running|Completed' | wc -l)
              if [ "$UNREADY" -eq 0 ]; then
                break
              fi
              sleep 10
            done
            UNREADY_FINAL=$(kubectl get pods -n "$NS" --no-headers | grep -vE 'Running|Completed' | wc -l)
            if [ "$UNREADY_FINAL" -ne 0 ]; then
              echo "Pods in $NS not healthy"
              exit 1
            fi
          done

      - name: Mark External DSF Completed
        run: |
          kubectl label namespace default external-dsf=completed --overwrite

  workflow-caller:
    runs-on: ubuntu-latest
    needs: deploy
    if: ${{ github.event_name == 'workflow_dispatch' }}
    steps:
      - name: Trigger helmsman mosip workflow via API
        env:
          GITHUB_REPO: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BRANCH: ${{ github.ref_name }}
        run: |
          curl -X PATCH \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            https://api.github.com/repos/$GITHUB_REPO \
            -d '{"default_branch":"'"$BRANCH"'"}'
          curl -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/$GITHUB_REPO/actions/workflows/helmsman_mosip.yml/dispatches \
            -d '{"ref":"'"$BRANCH"'","inputs":{"mode":"apply"}}'
