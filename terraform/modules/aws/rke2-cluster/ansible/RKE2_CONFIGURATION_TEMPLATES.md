# üéØ RKE2 Configuration Templates Guide

## **Template Types in the System**

### **1. üîß Terraform Templates (.tpl files)**

#### **A. User-Data Template (`rke-user-data.sh.tpl`)**
- **Purpose**: Controls instance initialization and primary control plane selection
- **Location**: `terraform/modules/aws/aws-resource-creation/rke-user-data.sh.tpl`
- **Key Features**:
  - Sets up instance metadata (role, index, IP)
  - Determines PRIMARY control plane selection
  - Configures environment variables
  - Prepares for Ansible execution

#### **B. Ansible Inventory Template (`inventory.yml.tpl`)**
- **Purpose**: Dynamic Ansible inventory generation
- **Location**: `terraform/modules/aws/rke2-cluster/ansible/inventory.yml.tpl`
- **Key Features**:
  - Generates inventory from Terraform data
  - Assigns node roles (control_plane, etcd, worker)
  - Sets primary/secondary flags
  - Configures connection parameters

### **2. üìã RKE2 Configuration Templates (from k8s-infra repo)**

The Ansible playbook expects these RKE2 configuration templates from the k8s-infra repository:

#### **A. Primary Control Plane Template**
```yaml
# File: rke2-server-control-plane-primary.conf.template
# Used for: First control plane node (CONTROL-PLANE-NODE-1)

# Basic cluster configuration
cluster-domain: ${CLUSTER_ENV_DOMAIN}
cluster-dns: 10.43.0.10

# Node configuration
node-name: ${NODE_NAME}
advertise-address: ${INTERNAL_IP}

# Network configuration
cluster-cidr: 10.42.0.0/16
service-cidr: 10.43.0.0/16

# Security and certificates
tls-san:
  - ${INTERNAL_IP}
  - ${CLUSTER_ENV_DOMAIN}
  - localhost
  - 127.0.0.1

# Disable components (if using external etcd)
disable: rke2-ingress-nginx

# Logging
log: /var/log/rke2.log
```

#### **B. Secondary Control Plane Template**
```yaml
# File: rke2-server-control-plane.subsequent.conf.template
# Used for: Secondary control plane nodes (CONTROL-PLANE-NODE-2, 3, ...)

# Join existing cluster
server: https://${PRIMARY_CONTROL_PLANE_IP}:9345
token: ${RKE2_TOKEN}

# Basic cluster configuration
cluster-domain: ${CLUSTER_ENV_DOMAIN}
cluster-dns: 10.43.0.10

# Node configuration
node-name: ${NODE_NAME}
advertise-address: ${INTERNAL_IP}

# Security and certificates
tls-san:
  - ${INTERNAL_IP}
  - ${CLUSTER_ENV_DOMAIN}

# Disable components
disable: rke2-ingress-nginx

# Logging
log: /var/log/rke2.log
```

#### **C. ETCD Nodes Template**
```yaml
# File: rke2-etcd-agents.conf.template
# Used for: Dedicated ETCD nodes (ETCD-NODE-1, 2, 3, ...)

# Join as agent to existing cluster
server: https://${PRIMARY_CONTROL_PLANE_IP}:9345
token: ${RKE2_AGENT_TOKEN}

# Node configuration
node-name: ${NODE_NAME}

# ETCD specific configuration
# (RKE2 will automatically configure this node as ETCD-only)

# Logging
log: /var/log/rke2.log
```

#### **D. Worker/Agent Nodes Template**
```yaml
# File: rke2-agents.conf.template
# Used for: Worker nodes (WORKER-NODE-1, 2, 3, ...)

# Join as agent to existing cluster
server: https://${PRIMARY_CONTROL_PLANE_IP}:9345
token: ${RKE2_AGENT_TOKEN}

# Node configuration
node-name: ${NODE_NAME}

# Worker node specific labels/taints (optional)
node-label:
  - "node-type=worker"

# Logging
log: /var/log/rke2.log
```

## **üîÑ Template Flow in Ansible Playbook**

### **Phase 1: Primary Control Plane**
```yaml
- name: Copy primary control plane config
  copy:
    src: "{{ rke2_config_dir }}/rke2-server-control-plane-primary.conf.template"
    dest: "{{ rke2_config_dir }}/config.yaml"
    remote_src: yes
```

### **Phase 2: All Other Nodes**

#### **Secondary Control Planes:**
```yaml
- name: Copy subsequent control plane config
  copy:
    src: "{{ rke2_config_dir }}/rke2-server-control-plane.subsequent.conf.template" 
    dest: "{{ rke2_config_dir }}/config.yaml"
    remote_src: yes
  when: node_role == "control_plane" and not (is_primary | default(false))
```

#### **ETCD Nodes:**
```yaml
- name: Copy ETCD config
  copy:
    src: "{{ rke2_config_dir }}/rke2-etcd-agents.conf.template"
    dest: "{{ rke2_config_dir }}/config.yaml" 
    remote_src: yes
  when: node_role == "etcd"
```

#### **Worker Nodes:**
```yaml
- name: Copy worker config
  copy:
    src: "{{ rke2_config_dir }}/rke2-agents.conf.template"
    dest: "{{ rke2_config_dir }}/config.yaml"
    remote_src: yes
  when: node_role == "worker"
```

## **üéØ Template Variable Substitution**

### **Key Variables Available in Templates:**
- `${CLUSTER_NAME}` - From Terraform
- `${CLUSTER_ENV_DOMAIN}` - From Terraform  
- `${NODE_NAME}` - From instance user-data
- `${INTERNAL_IP}` - From instance metadata
- `${PRIMARY_CONTROL_PLANE_IP}` - From first control plane
- `${RKE2_TOKEN}` - Generated by primary control plane
- `${RKE2_AGENT_TOKEN}` - Generated by primary control plane

### **Template Processing Flow:**
1. **Terraform** generates `rke-user-data.sh` from `.tpl`
2. **User-data** sets up environment variables
3. **Ansible** clones k8s-infra repo with `.conf.template` files
4. **Ansible** copies appropriate template to `config.yaml`
5. **RKE2** uses `config.yaml` for node configuration

## **üöÄ Key Benefits of Template Approach:**

1. **Separation of Concerns**:
   - Terraform handles infrastructure
   - User-data handles instance setup
   - Ansible handles orchestration
   - RKE2 templates handle cluster config

2. **Flexibility**:
   - Different configs for different node types
   - Easy customization per environment
   - Version controlled in k8s-infra repo

3. **Maintainability**:
   - Templates are reusable across environments
   - Changes in one place affect all deployments
   - Clear separation between infra and app config

4. **Enterprise Ready**:
   - Supports complex cluster topologies
   - Handles external ETCD scenarios
   - Scales from dev to production

## **üìù Current Implementation Status:**

‚úÖ **Terraform Templates**: Complete and enhanced
‚úÖ **Ansible Inventory Template**: Complete with all node types
‚úÖ **Ansible Playbook**: Complete with template copying logic
‚ö†Ô∏è **RKE2 Config Templates**: Expected from k8s-infra repository

The system is designed to pull RKE2 configuration templates from the k8s-infra repository during execution, ensuring they're always up-to-date and version controlled.
